---
title: 程序员的自我修养-链接-装载-库
date: 2025-11-21T19:46:47+08:00
draft: false
comment: true
weight: 0
hiddenFromHomePage: false
hiddenFromSearch: false
hiddenFromRss: false
hiddenFromRelated: false
description: "阅读下10多年前的这本书"
toc: true
lastmod: 2025-11-21T19:46:47+08:00
math: false
lightgallery: false

categories:
  - misc
# See details front matter: https://fixit.lruihao.cn/documentation/content-management/introduction/#front-matter
---

<!--more-->
接触编程很长时间了, 但很惭愧在这方面了解的比较少, 偶然在群里看到有大佬在讨论相关技术, 于是找到这本书来学一下

## 编译和链接

编译原理在本科是一门选修课, 当时认知很低, 没有好好学, 现在越发感兴趣, 于是来学一下

之前工作时使用Golang, 自己也学过一些Rust, 虽然它们都是编译型语言，但是对于其中的过程并不是那么清楚了解，
书中以c/cpp为例进行讲解(当时还没有Go和Rust哈哈), 接下来跟着书来学下, 读完这本书准备去系统学一下编译原理, 做个小的编译器

从源代码到执行经过四个步骤

1. 预处理
2. 编译
	1. 词法分析
	2. 语法分析
	3. 语义分析
	4. 中间代码生成
	5. 优化
3. 汇编
4. 链接

### 预处理

> 预处理过程主要处理那些源代码文件中以"`#`"开始的预编译指令, 比如 `#include`,`#define`, 删除所有注释等等, 详细的处理流程可自行检索

这里给出两个demo

#### 删除所有`#define`, 展开宏定义

使用gcc和-E参数: `gcc -E hello.c -o hello.i`, 输出如下, 可以看到所有的宏都被替换了, 注释也被删除了

{{< twocol >}}

```c {title="hello.c" hl_lines=[1,2,3]}
#define PI 3.1415926
#define RADIUS 5
#define AREA (PI * RADIUS * RADIUS)

// 这是一个注释
int main() {
    double area = AREA;

    return 0;
}
```

===

```c {title="hello.i" data-open=true hl_lines=13}
# 0 "hello.c"
# 0 "<built-in>"
# 0 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 0 "<command-line>" 2
# 1 "hello.c"





int main() {
    double area = (3.1415926 * 5 * 5);

    return 0;
}

```

{{< /twocol >}}

#### 注入#include中的内容

准备一个`simple.h`头文件

```c {title="simple.h"}
int add(int x, int y)
{
    return x + y;
}
```

使用`gcc -E hello.c -o hello.i`,可以看到预处理后的文件, 并且`simple.h`中的内容确实被复制了两行(参看高亮部分)

{{<twocol>}}

```c {title="hello.c" hl_lines=[2]}
#include "simple.h"
#include "simple.h" // 重复包含，预处理会把 simple.h 的内容复制两次

int main(void) {
    int d = add(3, 4);
    (void)d;
    return 0;
}
```

===

```c {title="hello.i" hl_lines=[8,14]}
# 0 "hello.c"
# 0 "<built-in>"
# 0 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 0 "<command-line>" 2
# 1 "hello.c"
# 1 "simple.h" 1
int add(int x, int y)
{
    return x + y;
}
# 2 "hello.c" 2
# 1 "simple.h" 1
int add(int x, int y)
{
    return x + y;
}
# 3 "hello.c" 2

int main(void) {
    int d = add(3, 4);
    (void)d;
    return 0;
}

```

{{</twocol>}}

### 编译

> 编译过程是将预处理完的文件进行词法分析，语法分析，语义分析等，优化后生成对应的汇编文件

```c {title="hello.c"}
#include <stdio.h>

int main(void) {
    printf("Hello, World!\n");
    return 0;
}
```

编译为汇编代码：`gcc -S hello.c -o hello.s`，上述内容被编译为下面的汇编代码

```gas {title="hello.s"}
.file	"hello.c"
	.text
	.section	.rodata
.LC0:
	.string	"Hello, World!"
	.text
	.globl	main
	.type	main, @function
main:
.LFB0:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	leaq	.LC0(%rip), %rax
	movq	%rax, %rdi
	call	puts@PLT
	movl	$0, %eax
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc
.LFE0:
	.size	main, .-main
	.ident	"GCC: (Ubuntu 11.4.0-1ubuntu1~22.04.2) 11.4.0"
	.section	.note.GNU-stack,"",@progbits
	.section	.note.gnu.property,"a"
	.align 8
	.long	1f - 0f
	.long	4f - 1f
	.long	5
0:
	.string	"GNU"
1:
	.align 8
	.long	0xc0000002
	.long	3f - 2f
2:
	.long	0x3
3:
	.align 8
4:

```

### 汇编

> 汇编器将汇编代码变成机器可以执行的指令，汇编过程主要是根据汇编指令和机器指令的对应关系，将汇编代码转换为目标文件（通常是二进制格式，如ELF、COFF等）

在上一节已经得到了编译后的汇编代码，现在用汇编器进行汇编输出目标文件：`as hello.s -o hello.o`，得到目标文件：`hello.o`

### 链接

> 将一个或多个目标文件以及库函数链接为一个可执行文件
> 1. 符号解析
> 2. 地址分配
> 3. 重定位
> 4. 合并代码和数据
> 5. 静态链接、动态链接
> 6. 符号冲突和重定义
> 7. 生成可执行文件或库

```bash {title="使用ld手动静态链接"}
/usr/bin/ld -static -o hello_static_ld \
  /usr/lib/x86_64-linux-gnu/crt1.o \
  /usr/lib/x86_64-linux-gnu/crti.o \
  /usr/lib/gcc/x86_64-linux-gnu/11/crtbeginT.o \
  hello.o \
  -L/usr/lib/gcc/x86_64-linux-gnu/11 \
  -L/usr/lib/x86_64-linux-gnu \
  --start-group -lc -lgcc -lgcc_eh --end-group \
  /usr/lib/gcc/x86_64-linux-gnu/11/crtend.o \
  /usr/lib/x86_64-linux-gnu/crtn.o

./hello_static_ld
```

gcc其实是上面那些命令的封装，通过不同的参数调用不同的命令

## 目标文件里有什么

## 静态链接
